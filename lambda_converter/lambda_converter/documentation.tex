\documentclass[]{report}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{listings}
\usepackage[margin=0.9in]{geometry}
\usepackage[toc,page]{appendix}
\usepackage{mathtools}
\renewcommand{\chaptername}{}
\lstdefinestyle{sharpc}{
 language=[Sharp]C, 		
 belowcaptionskip=1\baselineskip,
 breaklines=true,
 frame=L,
 xleftmargin=\parindent,
 showstringspaces=false,
 basicstyle=\footnotesize\ttfamily,
 rulecolor=\color{blue!80!black}
 }
    
% Title Page
\title{ECOTE Project (A21):  Program that converts C\# code with lambda expressions into code without lambda expressions}

\author{Author: Paweł Paczuski \\ Supervisor: dr inż. Anna Derezińska}

\begin{document}
    \maketitle
    
    \tableofcontents
    \pagebreak
    
    \chapter{Theoretical introduction}
    \section{$\lambda$ calculus in Mathematics}
    Lambda calculus was introduced as a mean of formalizing the concept of expressing computation based on function abstraction and application using variable binding and substitution long before computers and programming languages existed. \cite{lambddef}
    The central concept in $\lambda$ calculus is "expression". A  "name",  also  called a "variable", is an identifier which, for our purposes, can be any of the letters
    a,b,c,...
    An expression is defined recursively as follows\cite{lambdintro}:\\
    $<$expression$>:=< $name$ >|< $function$ >|< $application$ > $ \\
    $<$function $>:= \lambda < $name$ >.< $expression$ > $\\
    $<$application$>:=<$expression$ >< $expression$ > $\\
    
    $\lambda$  calculus can be used to express any computable function. Because of this fact it is equivalent to Turing machines but the computational power of $\lambda$ calculus is not connected in any way with hardware implementation. This concept is more likely to be implemented using software.
    
    \section{$\lambda$-calculus in programming}
    
    In spite of being object-oriented languages, C\# JAVA, C++, borrow several concepts from functional paradigm. One of them is the concept of anonymous function. Exemplary situation in which anonymous functions are useful can be filtering array using some set of predicates. Existing array is being iterated over and a function is called with each element of the array as its argument. The function examines properties of the element and returns boolean value. If the function returns true, the element is being pushed to the array that is result of filtering the former one. Otherwise, this element is skipped. 
    Using purely object-oriented approach, one would have to create an implementation of an interface that has a function that returns boolean value and is able to decide whether an element of the array satisfies all conditions. The problem with this solution is the distance between code that makes decision about an element and the place where function that filters the array was called. When somebody reads code written in this manner, the have to go to the definition of class and take a look at implementation of the interface method. A lot of boilerplate code is introduced and namespace is polluted with simple classes that provide no special functionality.
    This is the place where traditional $\lambda$ calculus gives practical tool that increases language expressiveness and therefore allows for writing code that is easier to read and has more bugs. One could define anonymous function that decides about filtering an item in the place of calling filter function making the code much more expressive. This idea was implemented in C\# language mechanism called LINQ 
    
    \section{Lambda expressions in C\#}\label{lambdatypes}
    Creators of C\# language decided to split syntax of a lambda expressions into several types.
    Lambda expressions in C\# language consist of arguments, $=>$ operator and expression or statement block.
    The $=>$ operator has the same precedence as assignment (=) and is right associative \cite{csharplambdasyntax}
    
    \subsection{Simple lambda expressions}
    The simplest lambda expressions. They are constituted of a single argument, $=>$ operator and expression. Types of arguments and returned value can be inferred. 
    \begin{lstlisting}[style=sharpc, caption=This lambda has single integer argument m and returns an integer m - 1]
    Func<int, int> lambd1 = m => m - 1;
    \end{lstlisting}

    \subsection{Parenthesized lambda expressions}    
    When lambda has more than one argument, parentheses have to be present. Single-argument lambda expression with parentheses also belongs to this category.
    \begin{lstlisting}[style=sharpc, caption=Lambda arguments can have types defined explicitly]
    Func<int, int, int> lambd2 = (int m, int n) => (m - n);
    \end{lstlisting}
    
    \subsection{Statement lambdas}
    Even more complex lambdas can contain statements within their body so, in addition to return value, they can have side effects.
    \begin{lstlisting}[style=sharpc, caption=execution lambd3 has side-effects that have no impact on the returned value]
    string text = "abc";
    Func<int, int> lambd3 = (n) =>
    {
        Console.WriteLine(text);
        Console.WriteLine(n);
        return n % 2;
    };
    \end{lstlisting}
    
    \subsection{Lambda expressions capturing local variables}
        Lambda expressions can implicitly capture local/instance variables. This has some serious implications e.g. when lambda expression capturing variable in a local block is assigned to a field of a class and then called in a different context, it has to be able to read value of a variable that used to be present in scope where it was assigned to the class field.
        \begin{lstlisting}[style=sharpc, caption="lambd4 has access to the local variable text in any context that. This property is sometimes called closure"]        
        string text = "this is some local text";
        Func<string, string> lambd4 = (n) => (text+n);
        \end{lstlisting}
    
    \subsection{Recursive lambda expressions}
    These are lambda expressions that can define other lambda expressions in their body. Due to limited practical applications (their syntax is not easy to read which is contrary to the expectation that lambdas are used to make code more readable), they are not described in a detailed way in this document.
    

        \begin{lstlisting}[style=sharpc, caption="factorial defined using lambda"]
        Func<Func<int, int>, Func<int, int>> factorial = (fac) => x => x == 0 ? 0 : x * fac(x - 1); 
        \end{lstlisting}
    
    \chapter{Lambda Converter for C\#}
    \section{Idea}
    The goal is to create a program (from now on referred to as Converter) that as an input receives source code written in C\# language that may contain lambda expressions of various kind. The program performs transformations of several kinds on the code in order to output modified version (but having the same functionality) of the code that contains no lambda expressions.
    \section{Transformation stages}
    The inner workings of the program can be split conceptually into several stages:
    \begin{enumerate}\label{transstages}
    \item       Syntactic analysis
    \item  		Semantic analysis
    \item       Code transformation
    \end{enumerate}
    \subsection{Syntactic analysis}
    In this stage the source code is analyzed in order to create syntax tree of the code. This data structure keeps all information about syntactic constructs in the input code. For a given syntax tree node, one can get information about its type, access modifier, identifier etc. 
    \subsection{Semantic analysis}
    Lambda conversion may require type inference for arguments and results, data flow information (what local scope variables are used in lambda's body), etc. These types of information can be taken from semantic model that is build using previously obtained syntax tree.
    
    \subsection{Code transformation}
    
    Information gathered in previous steps is used to find all lambda expressions in code that the program is capable of transforming. For each node transformation algorithm (described in section \ref{transalgorithm}) is applied.
    
    \section{Transformation algorithm}\label{transalgorithm}
    \begin{enumerate}
      \item {Determine which kind of lambda expression syntax described in section  \ref{lambdatypes} current lambda has}
   \item Determine names and types of lambda expression arguments
   \item Analyze what variables from the scope are referenced in lambda's body
   \item Create syntax node for a class declaration, give it unique identifier
   \item Add fields to the class syntax node that correspond to types of variables and names of variables referenced in lambda's body
   \item Create method syntax node that has the same return value as lambda, receives the same arguments and infer types of lambda's arguments. Its identifier can be e.g. "LambdaMethod". For statement lambda, copy original body into new method. For expression lambdas, add return keyword and concatenate with original body.
   \item Insert method syntax node into newly created class syntax node
   \item Insert class declaration syntax node into body of a class that contains lambda expression
   \item Find last expression or statement before original lambda expression.
   \item Create syntax nodes that correspond to instantiation of class, filling fields with values of variables from current scope. Insert those nodes just after the previously found node.
    \item Create method reference syntax node. Replace syntax node that used to define lambda expression with method reference node.
    \end{enumerate}
    
    \section{Roslyn}
    \subsection{Motivation}
    The problem of converting code containing lambda expressions has a lot of inherited complexity. The C\# language is a multi-paradigm language that evolved since its first release. Therefore, a grammar that defines it has many productions. The task of writing lexer and parser on our own as a subtask of the whole project would take a lot of time and effort to finish. Luckily, the creators of C\# language provide a set of open-source tools used to analyze and transform code called Roslyn. Roslyn exposes the C\#  compiler’s code analysis to a programmer as a consumer by providing an API layer that mirrors a traditional compiler pipeline. \cite{roslynrepo} Roslyn is used in the first two stages of operation of the Converter described in \ref{transstages}.

    \subsection{Architecture}
   
    Roslyn consists of two layers of API: compilers API and workspaces API.\\
    Compilers API provides programmer with object models that are used at each stage of the compilation: syntactic and semantic.\\
    Workspace API provides an object model to aggregate the code model across projects in a solution. Mainly for code analysis and refactoring around IDEs like Visual Studio, though the APIs are not dependent on Visual Studio\cite{workspaceapi}. 
    
    \subsubsection{Syntactic model}
    Syntactic model is represented mainly by a syntax tree whose nodes are called syntax nodes-constructs that represent syntactic elements such as statements, declarations, clauses, expressions, etc.\\
    \subsubsection{Semantic model}
    Semantic model adds to the syntactic model about language rules and how the information flows in regions of source code. 
    Semantic model uses symbols as representations of a distinct element declared by the source code or imported from an assembly as metadata. Every namespace, type, method, property, field, event, parameter, or local variable is represented by a symbol\cite{roslynoverview}.
    
    \subsubsection{Workspace}
    Workspace is an abstraction that describes solution as a collection of projects that contain documents with source code. This API is used in Converter in order to make syntax node insertion easier and efficient.
    

    \section{Errors}
    Main class of errors that can occur while executing Converter are those caused by improper syntax of the code.  
    
    \section{Tests}
    
    
    
    
    \section{Performance considerations}
    Due to immutability of the syntax tree implementation provided by Roslyn, each insertion creates a new snapshot of the tree. This has to be taken into consideration when inserting/removing nodes. Solution to it is to use built-in mechanism of batch-insertions. Because each modification creates new tree, a remembered place in the code is lost. To keep track of changes DocumentEditor abstraction can be used. It is helpful when one deals with many modifications but requires usage of workspace API that has performance drawbacks.
    
    \section{Practical applications}
    Increasing popularity of refactoring tools like Jetbrain's Resharper or tools included in Visual Studio installation like intellisense or refactor-suggestions make it quite possible that Lamba Converter could be used in this kind of tooling to allow for quick transformations of portions of code.
    \\
    One could also use Lambda Converter to teach about lambda expressions and how they can be implemented in programming languages.
    
    \section{Possible further improvements}

\pagebreak

    \section{Program code}

   \subsection{Program.cs}


    \lstinputlisting[style=sharpc]{"bin/Debug/Program.cs"}
    \pagebreak
    \subsection{TransformationInfo.cs}
    \lstinputlisting[style=sharpc]{"bin/Debug/TransformationInfo.cs"}
    \pagebreak
    \subsection{Input}
        \lstinputlisting[style=sharpc]{"bin/Debug/targetCode/LambdaCode.cs"}
            \pagebreak
    \subsection{Output}
        \lstinputlisting[style=sharpc]{"bin/Debug/targetCode/NonLambdaCode.cs"}  
                  
    
    
\begin{thebibliography}{80}
    \bibitem{lambdintro} R. Rojas, A Tutorial Introduction to the Lambda Calculus
    \bibitem{lambddef} https://en.wikipedia.org/wiki/Lambda\_calculus accessed \date{01.05.2017}
    \bibitem{csharpgrammar} https://msdn.microsoft.com/en-us/library/aa664812(v=vs.71).aspx
    \bibitem{csharplambdasyntax} https://msdn.microsoft.com/en-us/library/bb397687.aspx
    accessed \date{01.05.2017}
    \bibitem{roslynrepo} https://github.com/dotnet/roslyn
    \bibitem{roslynoverview} https://github.com/dotnet/roslyn/wiki/Roslyn Overview
    \bibitem{workspaceapi} http://www.amazedsaint.com/2011/10/c-vnext-roslynan-introduction-and-quick.html
    

\end{thebibliography}
\end{document}